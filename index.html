<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <!--

    @license twgl.js Copyright (c) 2015, Gregg Tavares All Rights Reserved.
    Available via the MIT license.
    see: http://github.com/greggman/twgl.js for details

    -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"/>
<meta property="og:description" content="TWGL.js - 2d-lines" />
<meta property="og:url" content="http://twgljs.org" />
<link rel="stylesheet" href="css/style.css"/>
<link rel="manifest" href="manifest.json"/>
<title>A Super Bug Zapper 3D Game</title>
<script type="text/javascript" src="common/webgl-utils.js"></script>
<script type="text/javascript" src="common/webgl-debug.js"></script>
<script type="text/javascript" src="common/webgl-debug.js" src = "node_modules/dat.gui/src/dat/index.js"> </script>
<script type="text/javascript" src="common/webgl-debug.js" src = "node_modules/dat.gui/src/dat/gui/gui.js"> </script>
<script type="text/javascript" src="tdl/base.js"></script>
<script type="text/javascript" src="https://rawgit.com/actarian/glsl-canvas/master/dist/glsl-canvas.min.js"></script>
<script type="text/javascript" id="globals">
    tdl.require('tdl.fps');
    tdl.require('tdl.fast');

    var aPosition;
    var at;

    var bugClickedOn = [];
    var bugColors = [];// colors for bugs
    var bugs = [];// array of bugs verts
    var bugsArray = [];
    var bugSpeed = 5;// interval at which bugs appear
    var bugVertices = 24;

    var circmax = 361;
    var clock = 0.0;
    var clx, cly;
    var colors;
    var currBugs = 0;
    var eye; 
    var eyeClock = 0;
    var frameCount = 0;
    var g_fpsTimer; 
    var gamePoints = 0;
    var incrementer = []; 
    var localMatrix;
    var maxvert = circmax + noOfBugs + (noOfBugs * noOfBugPoints);
    var modelViewMatrix;
    var noOfBugPoints = 1600;
    var noOfBugs = 25; //max number of bugs at once
    var noOfBugsKilled = 0;
    var normalize = false;
    var pointSize = 10;
    var poisonIncrementer = []; 
    var projectionMatrix;
    var radiusOfCircle = 0.4;
    var then = 0.0;
    var twgl;
    var up;
    var vertices = [];
    var vv;
    var WorldMatrix;

</script>

</head>
<body>
<div class="body">
<div id="fpsContainer">
  <div class="fpsInner">
    <div id="fullscreen"></div>
    <div class="fps">fps: <span id="fps"></span></div>
  </div>
</div>
<div id="b"><a href="http://lakeheadbedbug.hopto.org">Bug Zapp3D-'with a vengnece!!'</a> - lakeheadbedbug</div>
<div id="viewContainer">
<canvas id="c" width="800" height="800">
Oops ... your browser doesn't support the HTML5 canvas element
</canvas>
</div>
</div>
</body>

<script id="vs" type="notjs">
  uniform mat4 u_worldViewProjection;
  uniform vec3 u_lightWorldPos;
  uniform mat4 u_world;
  uniform mat4 u_viewInverse;
  uniform mat4 u_worldInverseTranspose;

  attribute vec4 a_position;
  attribute vec3 a_normal;
  attribute vec2 a_texcoord;

  varying vec4 v_position;
  varying vec2 v_texCoord;
  varying vec3 v_normal;
  varying vec3 v_surfaceToLight;
  varying vec3 v_surfaceToView;

  void main() {
    v_texCoord = a_texcoord;
    v_position = (u_worldViewProjection * a_position);
    v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;
    v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;
    v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;
    gl_Position = v_position;
  }
</script>

<script id="fs" type="notjs">
  precision mediump float;

  varying vec4 v_position;
  varying vec2 v_texCoord;
  varying vec3 v_normal;
  varying vec3 v_surfaceToLight;
  varying vec3 v_surfaceToView;

  uniform vec4 u_lightColor;
  uniform vec4 u_diffuseMult;
  uniform sampler2D u_diffuse;
  uniform vec4 u_specular;
  uniform float u_shininess;
  uniform float u_specularFactor;

  vec4 lit(float l ,float h, float m) {
    return vec4(1.0,
                abs(l),//max(l, 0.0),
                (l > 0.0) ? pow(max(0.0, h), m) : 0.0,
                1.0);
  }
  /*varying vec4 v_color;
  uniform vec4 u_colorMult;
  uniform vec4 u_colorOffset; 
  */
  void main() {
    vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;
    vec3 a_normal = normalize(v_normal);
    vec3 surfaceToLight = normalize(v_surfaceToLight);
    vec3 surfaceToView = normalize(v_surfaceToView);
    vec3 halfVector = normalize(surfaceToLight + surfaceToView);
    vec4 litR = lit(dot(a_normal, surfaceToLight),
                      dot(a_normal, halfVector), u_shininess);
    vec4 outColor = vec4((u_lightColor * (diffuseColor * litR.y +
          u_specular * litR.z * u_specularFactor)).rgb, diffuseColor.a);
    gl_FragColor = outColor;
  }
</script>

<script type="text/javascript" src="node_modules/twgl.js/dist/4.x/twgl-full.js"></script>
<script src="3rdparty/chroma.min.js"></script>

<script type="text/javascript">
    /*BOILERPLATE SETUP*/
    "use strict";
    twgl.setDefaults({attribPrefix: "a_"});
    const m4 = twgl.m4;
    const gl = document.querySelector("#c").getContext("webgl");
    const programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);
    g_fpsTimer = new tdl.fps.FPSTimer();

    const shapes = [
    //twgl.primitives.createCubeBufferInfo(gl, 2),
    twgl.primitives.createSphereBufferInfo(gl, 5, 48, 24),
    twgl.primitives.createSphereBufferInfo(gl, 0.5, 12, 5),
    //twgl.primitives.createPlaneBufferInfo(gl, 2, 2),
    //twgl.primitives.createTruncatedConeBufferInfo(gl, 1, 0, 2, 24, 1),
    //twgl.primitives.createCresentBufferInfo(gl, 1, 1, 0.5, 0.1, 24),
    //twgl.primitives.createCylinderBufferInfo(gl, 1, 2, 24, 2),
    //twgl.primitives.createDiscBufferInfo(gl, 1, 24),
    //twgl.primitives.createTorusBufferInfo(gl, 1, 0.4, 24, 12),
    ];
  
    /* Helps setup parent child scene relationships*/
    /*var Node = function() {
      this.children = [];
      this.localMatrix = m4.identity();
      this.worldMatrix = m4.identity();
    };

    Node.prototype.setParent = function(parent) {
      // remove us from our parent
      if (this.parent) {
        var ndx = this.parent.children.indexOf(this);
        if (ndx >= 0) {
          this.parent.children.splice(ndx, 1);
        }
      }
      // Add us to our new parent
      if (parent) {
        parent.children.append(this);
      }
      this.parent = parent;
    };

    Node.prototype.updateWorldMatrix = function(parentWorldMatrix) {
      if (parentWorldMatrix) {
        // a matrix was passed in so do the math and
        // store the result in `this.worldMatrix`.
        m4.multiply(this.localMatrix, parentWorldMatrix, this.worldMatrix);
      } else {
        // no matrix was passed in so just copy localMatrix to worldMatrix
        m4.copy(this.localMatrix, this.worldMatrix);
      }
    
      // now process all the children
      var worldMatrix = this.worldMatrix;
      this.children.forEach(function(child) {
        child.updateWorldMatrix(worldMatrix);
      });
  };*/

  function rand(min, max) {
      return min + Math.random() * (max - min);
    }

    // Shared values
    const lightWorldPosition = [1, 8, -10];
    const lightColor = [1, 1, 1, 1];
    const camera = m4.identity();
    const view = m4.identity();
    const viewProjection = m4.identity();
    var fpsElem = document.getElementById("fps");

    const tex = twgl.createTexture(gl, {
      /*Applies beach ball like texture so that spehere movement can be seen
      brtter through lighting effect*/
      min: gl.NEAREST,
      mag: gl.NEAREST,
      src: [
        255, 255, 255, 255,
        192, 192, 192, 255,
        192, 192, 192, 255,
        255, 255, 255, 255,
      ],
    });

    const objects = [];
    const drawObjects = [];
    const numObjects = 2;
    const baseHue = rand(0, 360);
    for (let ii = 0; ii < numObjects; ++ii) {
      const uniforms = {
        u_lightWorldPos: lightWorldPosition,
        u_lightColor: lightColor,
        u_diffuseMult: chroma.hsv((baseHue+(ii*10) + rand(0, 60) % 360), 0.5+(ii*0.5), 0.8+(ii*0.1)).gl(),
        u_specular: [1, 1, 1, 1],
        u_shininess: 75,
        u_specularFactor: 1,
        u_diffuse: tex,
        u_viewInverse: camera,
        u_world: m4.identity(),
        u_worldInverseTranspose: m4.identity(),
        u_worldViewProjection: m4.identity(),
      };
      drawObjects.push({
        programInfo: programInfo,
        bufferInfo: shapes[ii % shapes.length],
        uniforms: uniforms,
      });
        if (ii == 0) {
        objects.push({
          //translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],
          translation: [ 0.0, 0.0, 0.0],
          ySpeed: rand(0.0, 0.0),
          zSpeed: rand(0.1, 0.3),
          uniforms: uniforms,
        });
        }
      if (ii > 0) {
      objects.push({
        //translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],
        translation: [ 1, 1, -5],
        ySpeed: rand(0.2, 0.4),
        zSpeed: rand(0.2, 0.4),
        uniforms: uniforms,
      });
      }
    }

  var createFlattenedVertices = function(gl, vertices) {
      var last;
      return webglUtils.createBufferInfoFromArrays(
          gl,
          primitives.makeRandomVertexColors(
              primitives.deindexVertices(vertices),
              {
                vertsPerColor: 1,
                rand: function(ndx, channel) {
                  if (channel === 0) {
                    last = 128 + Math.random() * 128 | 0;
                  }
                  return channel < 3 ? last : 255;
                }
              })
        );
    };

  var ctx = WebGLDebugUtils.makeDebugContext(c.getContext("webgl"));
  
  //var objectsToDraw = [];//also objects[]
  /*
  // make all the nodes
  var sphereNode = new Node();
    sphereNode.localMatrix = m4.translation(0, 0, 0);//it's already at centre of world
    sphereNode.drawInfo = {
      uniforms: {
        u_colorOffset: [0.6, 0.6, 0, 1], // 
        u_colorMult:   [0.5, 0.5, 0, 1],
      },
      programInfo: programInfo,
      bufferInfo: sphereBufferInfo,
    };

  var bugsNode = new Node();
    bugsNode.localMatrix = m4.translation(100, 0, 0);  // earth 100 units from the sun
    bugsNode.drawInfo = {
      uniforms: {
        u_colorOffset: [0.2, 0.5, 0.8, 1],  // blue-green
        u_colorMult:   [0.8, 0.5, 0.2, 1],
      },
      programInfo: programInfo,
      bufferInfo: sphereBufferInfo,
    };
  
  // connect the scene objects
  bugsNode.setParent(sphereNode);

  objects = [
      sphereNode,
      bugsNode,
    ];
  */

  function render(time) {
      time *= 0.001;
      ++frameCount;
      var now = (new Date()).getTime() * 0.001;
      var elapsedTime;
      if(then == 0.0) {
      elapsedTime = 0.0;
      } else {
      elapsedTime = now - then;
      }
      then = now;
      clock += elapsedTime;
      //eye speed 1/10 of elapsed time
      twgl.resizeCanvasToDisplaySize(gl.canvas);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      gl.enable(gl.DEPTH_TEST);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);
      const eye = [1, 4, -20];
      const target = [0, 0, 0];
      const up = [0, 1, 0];

      g_fpsTimer.update(elapsedTime);
      fpsElem.innerHTML = g_fpsTimer.averageFPS;

      m4.lookAt(eye, target, up, camera);
      m4.inverse(camera, view);
      m4.multiply(projection, view, viewProjection);

      objects.forEach(function(obj) {
        var i=0;
        const uni = obj.uniforms;
        const world = uni.u_world;
        m4.identity(world);
        m4.rotateY(world, time * obj.ySpeed, world);
        m4.rotateZ(world, time * obj.zSpeed, world);
        m4.translate(world, obj.translation, world);
        m4.rotateX(world, time, world);
        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);
        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);
        });

        twgl.drawObjectList(gl, drawObjects);

        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js"></script>

</html>